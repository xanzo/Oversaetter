Exercise 1
1a)
call-by-value er r = 7, x = 3 og y = 1.
Det er disse værdier der bliver kaldt og bliver ikke overskrevet noget sted.

1b)
call-by-reference ville printe r = 12, x = 3, y = 1.
f bliver kaldt med (3,1,3)
a = y + x = 4
b = x - y = 2
c = x + x = 6
4+2+6 = 12

1c)
call-by-value-result bliver r = 15, x = 8, y = 3.
Man kalder f med (3,1,3). 
x = 1 + 3 = 4
y = 4 - 1 = 3
x = 4 + 4 = 8


Exercise 2
2a) static scoping:
f(3) ville printe 6, eftersom global x = 4, derfor kaldes h(y) hvor x bliver = y + 2, hvor y = 4, derefter kaldes g() der printer.
f(5) ville printe 6, eftersom global x = 4, derfor kaldes h(y) hvor x bliver = y + 2, hvor y = 4, derefter kaldes g() der printer.

2b) dynamic scoping:
f(3) ville printe 3, eftersom x = 3 derfor kaldes g() som printer x.
f(5) ville printe 7, eftersom h(y) kaldes hvor x bliver til y + 2, hvor y = 5, derefter kaldes g() der printer.


Exercise 3
3a) 
Den kan køre programmet, så længe x ikke er 33. ellers vil den returnere en Int hvilket er korrekt.
Hvis man taster 33 ind vil den prøve at returnere c som er en char, og der vil komme type fejl

3b)
filter: (f,{ a1, a2, ... }) = { ai | ai ? { a1, a2, ... } ? f(ai) is true }
-Tjek om typerne er korrekte.
-Tjek om ai findes i listen {a1, a2, ...}.
-Lav en liste med de steder hvor ai findes i den oprindelige liste.

scan: (f, e, { a1, a2, ... }) = { e, f(e, a1), f(f(e, a1), a2), ... }
(a * a -> a) * a * [a] ? [a]
-Tjek om typerne er korrekte.
-Brug funktionen på alle elementer i listen.
-Starter på plads e( se ovenstående beskrivelse af scan) i listen.
-Beregner alle elementer i listen fra e og frem.

Exercise 4