Exercise 1
1a)
x = 3
y = 1
a = x = 3
b = y = 1
c = x = 3
r = a + b + c = 3 + 1 + 3 = 7
call-by-value er r = 7, x = 3 og y = 1.

1b)
call-by-reference ville printe r = 12, x = 3, y = 1.
f bliver kaldt med (3,1,3)
a = y + x = 4
b = x - y = 2
c = x + x = 6
4+2+6 = 12

1c)
call-by-value-result bliver r = 15, x = 8, y = 3.
Man kalder f med (3,1,3). 
x = 1 + 3 = 4
y = 4 - 1 = 3
x = 4 + 4 = 8


Exercise 2
2a) static scoping:
f(3) ville printe 6, eftersom global x = 4, derfor kaldes h(y) hvor x bliver = y + 2,
hvor y = 4, derefter kaldes g() der printer.
f(5) ville printe 7, eftersom global x = 4, derfor kaldes h(y) hvor x bliver = y + 2,
hvor y = x fra f(x) = 5, derefter kaldes g() der printer.

2b) dynamic scoping:
f(3) ville printe 3, eftersom x = 3 derfor kaldes g() som printer x.
f(5) ville printe 7, eftersom h(y) kaldes hvor x bliver til y + 2, hvor y = 5,
derefter kaldes g() der printer.


Exercise 3
3a)
fun int main() = let x = read(int) in
				 if x == 33 then ’c’ else x + 3

Den kan køre programmet, så længe x ikke er 33. ellers vil den returnere en Int hvilket er korrekt.
Hvis man taster 33 ind vil den prøve at returnere c som er en char, og der vil komme type fejl

3b)
filter: (a -> bool) * [a] -> [a]
Filter skal tjekke om første element er en funktion af et argument af typen t, som
skal give en sandhedsresultat(boolian).
At andet argument også er af typen t.

scan: (a * a -> a) * a * [a] -> [a]
Scan skal tjekke at første element er en funktion af to argumenter som
begge har samme type t.
At andet argument har typen t.
At tredje argument har typen Array t

Exercise 4
4a)
Hvis man skal implementere dynamic scoping skal man kalde med vtab der bliver brugt i EvalExp.
Dette kan man dog ikke, da denne kalder CallFun der ikke kan tage imod et vtab,
men selv genererer tomme variable. Derfor skal man i stedet for at kalde CallFun,
skal man blot kalde CallFunWithVtable.
Man kan ændre ved:
evalExp ( Apply(fid, args, pos), vtab, ftab ) = ... callFunWithVtable(f, evargs, vtab, ftab, pos)

4b)
 |  evalFunArg (Lambda (rettype, params, body, fpos), vtab, ftab, callpos) =
	
        NONE   => raise Error("Function "^fid^" is not in SymTab!", callpos)
      | SOME f => (fn aargs => callFunwithVtable(f, aargs, vtab, ftab, callpos), getFunRTP f)
	  
	  
	  
	evalFunArg (FunName fid, vtab, ftab, callpos) =
		let
			val fexp = SymTab.lookup fid ftab
		in
			case fexp of
			NONE   => raise Error("Function "^fid^" is not in SymTab!", callpos)
		| 	SOME f => (fn aargs => callFun(f, aargs, ftab, callpos), getFunRTP f)
		end
  | evalFunArg (Lambda (rettype, params, body, fpos), vtab, ftab, callpos) =
			(fn aargs => callFunwithVtable(rettype, params, body, fpos, aargs, vtab, ftab, callpos), getFunRTP aargs)
 
 
 
 
 
 (* evalFunArg takes as argument a FunArg, a vtable, an ftable, and the
position where the call is performed.

It returns a pair of two values: an anonymous SML function, and the
return type of the FunArg.  The anonymous function that is returned
takes a single argument - a list of arguments that should be applied
to the function.  This allows us to evaluate a FunArg once, then call
it several times in a loop.
 *)
and evalFunArg (FunName fid, vtab, ftab, callpos) =
    let
      val fexp = SymTab.lookup fid ftab
    in
      case fexp of
        NONE   => raise Error("Function "^fid^" is not in SymTab!", callpos)
      | SOME f => (fn aargs => callFun(f, aargs, ftab, callpos), getFunRTP f)
    end
	
callFunWithVtable (FunDec (fid, rtp, fargs, body, pdcl), aargs, vtab, ftab, pcall)